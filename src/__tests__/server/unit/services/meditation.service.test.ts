// IMPORTANT: Import prismaMock BEFORE meditation.service to activate the mock
import { getMockPrisma } from '@/__tests__/utils/prismaMock';
import type { MockPrismaClient } from '@/__tests__/utils/prismaMock';
import { createTestMeditation } from '@/__tests__/utils/testHelpers';
import { describe, it, expect, beforeEach } from 'vitest';

// FEAT-3: Meditation service unit tests

import {
  createMeditation,
  getMeditation,
  listMeditations,
  updateMeditation,
  deleteMeditation,
} from '@/server/services/meditation.service';
import { AuthError } from '@/server/middleware/auth.middleware';

describe('MeditationService', () => {
  let mockPrisma: MockPrismaClient;

  beforeEach(() => {
    mockPrisma = getMockPrisma();
  });

  // =========================================
  // createMeditation
  // =========================================
  describe('묵상 노트 생성 (createMeditation)', () => {
    const createData = {
      content: '하나님의 사랑에 대한 묵상입니다.',
      analysisId: 'test-analysis-id-1',
    };

    it('성공적으로 묵상 노트를 생성한다', async () => {
      const createdMeditation = createTestMeditation({
        content: createData.content,
        analysisId: createData.analysisId,
        status: 'published',
        isAutoGenerated: false,
      });

      mockPrisma.meditation.create.mockResolvedValue(createdMeditation);

      const result = await createMeditation('test-user-id-1', createData);

      expect(result.id).toBe('test-meditation-id-1');
      expect(result.content).toBe(createData.content);
      expect(result.isAutoGenerated).toBe(false);
      expect(result.status).toBe('published');
      expect(mockPrisma.meditation.create).toHaveBeenCalledWith({
        data: {
          userId: 'test-user-id-1',
          analysisId: createData.analysisId,
          content: createData.content,
          isAutoGenerated: false,
          status: 'published',
        },
      });
    });
  });

  // =========================================
  // listMeditations
  // =========================================
  describe('묵상 목록 조회 (listMeditations)', () => {
    it('성공적으로 묵상 목록을 반환한다', async () => {
      const meditations = [
        {
          id: 'meditation-1',
          analysisId: 'analysis-1',
          content: '짧은 묵상 내용입니다.',
          isAutoGenerated: false,
          status: 'published',
          createdAt: new Date('2026-01-02T00:00:00Z'),
        },
        {
          id: 'meditation-2',
          analysisId: null,
          content: 'A'.repeat(150),
          isAutoGenerated: true,
          status: 'draft',
          createdAt: new Date('2026-01-01T00:00:00Z'),
        },
      ];

      mockPrisma.meditation.findMany.mockResolvedValue(meditations);
      mockPrisma.meditation.count.mockResolvedValue(15);

      const result = await listMeditations('test-user-id-1', { page: 1, limit: 10 });

      expect(result.items).toHaveLength(2);
      expect(result.items[0]!.content).toBe('짧은 묵상 내용입니다.');
      expect(result.items[1]!.content).toBe('A'.repeat(100) + '...');
      expect(result.meta).toEqual({
        page: 1,
        limit: 10,
        total: 15,
        totalPages: 2,
      });
      expect(mockPrisma.meditation.findMany).toHaveBeenCalledWith({
        where: { userId: 'test-user-id-1' },
        orderBy: { createdAt: 'desc' },
        skip: 0,
        take: 10,
        select: {
          id: true,
          analysisId: true,
          content: true,
          isAutoGenerated: true,
          status: true,
          createdAt: true,
        },
      });
      expect(mockPrisma.meditation.count).toHaveBeenCalledWith({
        where: { userId: 'test-user-id-1' },
      });
    });

    it('빈 목록을 반환한다', async () => {
      mockPrisma.meditation.findMany.mockResolvedValue([]);
      mockPrisma.meditation.count.mockResolvedValue(0);

      const result = await listMeditations('test-user-id-1', { page: 1, limit: 10 });

      expect(result.items).toHaveLength(0);
      expect(result.meta).toEqual({
        page: 1,
        limit: 10,
        total: 0,
        totalPages: 0,
      });
    });
  });

  // =========================================
  // getMeditation
  // =========================================
  describe('묵상 조회 (getMeditation)', () => {
    it('성공적으로 묵상을 조회한다', async () => {
      const meditation = createTestMeditation();

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);

      const result = await getMeditation('test-user-id-1', 'test-meditation-id-1');

      expect(result.id).toBe('test-meditation-id-1');
      expect(result.content).toBe(meditation.content);
      expect(mockPrisma.meditation.findUnique).toHaveBeenCalledWith({
        where: { id: 'test-meditation-id-1' },
      });
    });

    it('존재하지 않으면 404 에러를 던진다', async () => {
      mockPrisma.meditation.findUnique.mockResolvedValue(null);

      await expect(getMeditation('test-user-id-1', 'non-existing-id')).rejects.toThrow(AuthError);

      try {
        await getMeditation('test-user-id-1', 'non-existing-id');
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('묵상 노트를 찾을 수 없습니다');
        expect((e as AuthError).statusCode).toBe(404);
      }
    });

    it('다른 사용자의 묵상 조회 시 403 에러를 던진다', async () => {
      const meditation = createTestMeditation({ userId: 'other-user-id' });

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);

      await expect(getMeditation('test-user-id-1', 'test-meditation-id-1')).rejects.toThrow(
        AuthError,
      );

      try {
        await getMeditation('test-user-id-1', 'test-meditation-id-1');
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('접근 권한이 없습니다');
        expect((e as AuthError).statusCode).toBe(403);
      }
    });
  });

  // =========================================
  // updateMeditation
  // =========================================
  describe('묵상 수정 (updateMeditation)', () => {
    it('성공적으로 수정한다', async () => {
      const meditation = createTestMeditation({ status: 'draft' });
      const updatedMeditation = createTestMeditation({
        content: '수정된 묵상 내용입니다.',
        status: 'published',
      });

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);
      mockPrisma.meditation.update.mockResolvedValue(updatedMeditation);

      const result = await updateMeditation('test-user-id-1', 'test-meditation-id-1', {
        content: '수정된 묵상 내용입니다.',
      });

      expect(result.content).toBe('수정된 묵상 내용입니다.');
      expect(result.status).toBe('published');
      expect(mockPrisma.meditation.update).toHaveBeenCalledWith({
        where: { id: 'test-meditation-id-1' },
        data: {
          content: '수정된 묵상 내용입니다.',
          status: 'published',
        },
      });
    });

    it('존재하지 않으면 404 에러를 던진다', async () => {
      mockPrisma.meditation.findUnique.mockResolvedValue(null);

      await expect(
        updateMeditation('test-user-id-1', 'non-existing-id', { content: '내용' }),
      ).rejects.toThrow(AuthError);

      try {
        await updateMeditation('test-user-id-1', 'non-existing-id', { content: '내용' });
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('묵상 노트를 찾을 수 없습니다');
        expect((e as AuthError).statusCode).toBe(404);
      }
    });

    it('다른 사용자의 묵상 수정 시 403 에러를 던진다', async () => {
      const meditation = createTestMeditation({ userId: 'other-user-id' });

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);

      await expect(
        updateMeditation('test-user-id-1', 'test-meditation-id-1', { content: '내용' }),
      ).rejects.toThrow(AuthError);

      try {
        await updateMeditation('test-user-id-1', 'test-meditation-id-1', { content: '내용' });
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('접근 권한이 없습니다');
        expect((e as AuthError).statusCode).toBe(403);
      }
    });
  });

  // =========================================
  // deleteMeditation
  // =========================================
  describe('묵상 삭제 (deleteMeditation)', () => {
    it('성공적으로 삭제한다', async () => {
      const meditation = createTestMeditation();

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);
      mockPrisma.meditation.delete.mockResolvedValue(meditation);

      const result = await deleteMeditation('test-user-id-1', 'test-meditation-id-1');

      expect(result.id).toBe('test-meditation-id-1');
      expect(mockPrisma.meditation.delete).toHaveBeenCalledWith({
        where: { id: 'test-meditation-id-1' },
      });
    });

    it('존재하지 않으면 404 에러를 던진다', async () => {
      mockPrisma.meditation.findUnique.mockResolvedValue(null);

      await expect(deleteMeditation('test-user-id-1', 'non-existing-id')).rejects.toThrow(
        AuthError,
      );

      try {
        await deleteMeditation('test-user-id-1', 'non-existing-id');
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('묵상 노트를 찾을 수 없습니다');
        expect((e as AuthError).statusCode).toBe(404);
      }
    });

    it('다른 사용자의 묵상 삭제 시 403 에러를 던진다', async () => {
      const meditation = createTestMeditation({ userId: 'other-user-id' });

      mockPrisma.meditation.findUnique.mockResolvedValue(meditation);

      await expect(deleteMeditation('test-user-id-1', 'test-meditation-id-1')).rejects.toThrow(
        AuthError,
      );

      try {
        await deleteMeditation('test-user-id-1', 'test-meditation-id-1');
      } catch (e) {
        expect(e).toBeInstanceOf(AuthError);
        expect((e as AuthError).message).toBe('접근 권한이 없습니다');
        expect((e as AuthError).statusCode).toBe(403);
      }
    });
  });
});
