import OpenAI from 'openai';
import { prisma } from '@/lib/prisma';
import { AuthError } from '@/server/middleware/auth.middleware';
import { aiConfig } from '@/server/config/ai.config';
import { buildMeditationPrompt } from '@/server/prompts/meditation-v1.prompt';
import type { CreateMeditationRequest } from '@contracts/meditation.contract';

// FEAT-3: Meditation CRUD service

export async function createMeditation(userId: string, data: CreateMeditationRequest) {
  const meditation = await prisma.meditation.create({
    data: {
      userId,
      analysisId: data.analysisId ?? null,
      content: data.content,
      isAutoGenerated: false,
      status: 'published',
    },
  });

  return {
    id: meditation.id,
    userId: meditation.userId,
    analysisId: meditation.analysisId,
    content: meditation.content,
    isAutoGenerated: meditation.isAutoGenerated,
    status: meditation.status,
    createdAt: meditation.createdAt,
    updatedAt: meditation.updatedAt,
  };
}

export async function listMeditations(
  userId: string | null,
  query: { page: number; limit: number },
) {
  const { page, limit } = query;
  const where = userId ? { userId } : { userId: null as string | null };

  const [items, total] = await Promise.all([
    prisma.meditation.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
      select: {
        id: true,
        analysisId: true,
        content: true,
        isAutoGenerated: true,
        status: true,
        createdAt: true,
      },
    }),
    prisma.meditation.count({ where }),
  ]);

  const truncatedItems = items.map((item) => ({
    ...item,
    content: item.content.length > 100 ? item.content.slice(0, 100) + '...' : item.content,
  }));

  return {
    items: truncatedItems,
    meta: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
}

export async function getMeditation(userId: string, meditationId: string) {
  const meditation = await prisma.meditation.findUnique({
    where: { id: meditationId },
  });

  if (!meditation) {
    throw new AuthError('묵상 노트를 찾을 수 없습니다', 404);
  }

  if (meditation.userId !== userId) {
    throw new AuthError('접근 권한이 없습니다', 403);
  }

  return meditation;
}

export async function updateMeditation(
  userId: string,
  meditationId: string,
  data: { content: string },
) {
  const meditation = await prisma.meditation.findUnique({
    where: { id: meditationId },
  });

  if (!meditation) {
    throw new AuthError('묵상 노트를 찾을 수 없습니다', 404);
  }

  if (meditation.userId !== userId) {
    throw new AuthError('접근 권한이 없습니다', 403);
  }

  const updated = await prisma.meditation.update({
    where: { id: meditationId },
    data: {
      content: data.content,
      status: meditation.status === 'draft' ? 'published' : meditation.status,
    },
  });

  return updated;
}

export async function deleteMeditation(userId: string, meditationId: string) {
  const meditation = await prisma.meditation.findUnique({
    where: { id: meditationId },
  });

  if (!meditation) {
    throw new AuthError('묵상 노트를 찾을 수 없습니다', 404);
  }

  if (meditation.userId !== userId) {
    throw new AuthError('접근 권한이 없습니다', 403);
  }

  await prisma.meditation.delete({
    where: { id: meditationId },
  });

  return { id: meditationId };
}

export async function generateMeditation(userId: string, analysisId: string) {
  const analysis = await prisma.analysis.findUnique({
    where: { id: analysisId },
    include: { result: true },
  });

  if (!analysis) {
    throw new AuthError('분석 결과를 찾을 수 없습니다', 404);
  }

  if (analysis.userId !== userId) {
    throw new AuthError('접근 권한이 없습니다', 403);
  }

  if (!analysis.result) {
    throw new AuthError('분석 결과가 아직 준비되지 않았습니다', 400);
  }

  const { systemPrompt, userPrompt } = buildMeditationPrompt(
    analysis.passageText,
    analysis.book,
    analysis.chapter,
    analysis.verseStart,
    analysis.verseEnd,
    analysis.result.explanation,
  );

  const openai = new OpenAI({ apiKey: aiConfig.apiKey });

  const completion = await openai.chat.completions.create({
    model: aiConfig.model,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    max_tokens: aiConfig.maxTokens,
    temperature: 0.7,
  });

  const content = completion.choices[0]?.message?.content;
  if (!content) {
    throw new Error('AI 응답이 비어있습니다');
  }

  const meditation = await prisma.meditation.create({
    data: {
      userId,
      analysisId,
      content,
      isAutoGenerated: true,
      status: 'draft',
    },
  });

  return {
    id: meditation.id,
    content: meditation.content,
    isAutoGenerated: meditation.isAutoGenerated,
  };
}
